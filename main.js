#!/usr/bin/env node

const HELP_MSG = `vuextcg [store-definition.js] [output]

Read the input Vuex definition file to output a ES2015 module file which exports
two properties:

  * getters: contains upper case properties with the getters types
  * mutations: contains upper case properties with the mutations types
  * actions: contains upper case properties with the actions types

The Vuex definition file is required and has to be a module with a default
exports with the store definition.

The output file is optional, using the standard output when isn't specified.

Each type defined in mutations and actions is an uppercase and snake case
property, which starts (first word) with namespace (if it's a Vuex module with
the namespace set to true), following the subnamespaces (in case that it's
nested Vuex namespaced module) and the type; moreover if any of the namespaces
or the type are camel case, then they will become to snake case name before
uppercasing them.

Example
// store-definition.js
exports default {
  ...
  mutations: {
    increment(state) {
      state.count++
    }
  },
  modules: {
    account: {
      namespace: true,
      mutations: {
        increment(state) {
          state.count += 2
        }
      },

      modules: {
        settings: {
          namespace: true,
          getters: {
            isAdmin() {...}
          }
        }
      }
    },
    user: {
      actions: {
        getProfile() {....}
      }
    }
  }
}

# Output:
// DO NOT MODIFY THIS FILE: AUTOGENERATED BY vuextcg
exports const getters = {
  ACCOUNT_SETTINGS_IS_ADMIN = 'account/settings/isAdmin'
}

exports const mutations = {
  INCREMENT: 'increment',
  ACCOUNT_INCREMENT: 'account/increment',
}

exports const actions = {
  GET_PROFILE: 'getProfile'
}
`

require('babel-register')({
  presets: ['es2015', 'stage-2'],
  plugins: ['transform-runtime']
})

const fs = require('fs')
const snakeCase = require('snake-case')

const storeDefFilepath = process.argv[2]
// Write the provided file, otherwise to stdout
const outputFd = (process.argv[3])
  ? fs.openSync(process.argv[3], 'w+', parseInt('777', 8)) : 1

if (!storeDefFilepath) {
  exitWithError(`Error: the store definition filepath is required.

${HELP_MSG}
  `)
}

const storeDef = require(storeDefFilepath).default

const getters = []
const mutations = []
const actions = []

extract(storeDef, [])

// Lexicographical sort the const for each group
;[getters, mutations, actions].forEach(g => {
  g.sort((c1, c2) => {
    // Same namespsace level, then sort them lexicographically
    if (c1[2] === c2[2]) {
      if (c1[0] < c2[0]) {
        return -1
      } else {
        return 1
      }
    }

    return (c1[2] < c2[2]) ? -1 : 1
  })
})

fs.writeSync(
  outputFd, '// DO NOT MODIFY THIS FILE: AUTOGENERATED BY vuextcg', null, 'utf8'
)

// Write the output
let isFirstExport = true
;[
  ['getters', getters],
  ['mutations', mutations],
  ['actions', actions]
].forEach(g => {
  if (g[1].length === 0) {
    return
  }

  let exportInst
  if (isFirstExport) {
    exportInst = '\n'
    isFirstExport = false
  } else {
    exportInst = '\n\n'
  }

  exportInst += `export const ${g[0]} = {\n`
  fs.writeSync(outputFd, exportInst, null, 'utf8')

  let globalsEnded = false

  g[1].forEach((c, idx, list) => {
    if (!globalsEnded) {
      if (c[2] > 0) {
        globalsEnded = true

        let sep = (idx > 0) ? '\n  ' : ''
        sep += '// Namespaced\n'

        fs.writeSync(outputFd, sep, null, 'utf8')
      } else if (idx === 0) {
        fs.writeSync(outputFd, '  // Globals\n', null, 'utf8')
      }
    }

    let prop = `  ${c[0]}: '${c[1]}'`
    prop += (idx === (list.length - 1)) ? '\n' : ',\n'

    fs.writeSync(outputFd, prop, null, 'utf8')
  })

  fs.writeSync(outputFd, '}', null, 'utf8')
})

fs.writeSync(outputFd, '\n', null, 'utf8')
fs.closeSync(outputFd)

/** *** Helper functions *****/
/**
 * Return the constant uppercase-snakecase identifier, the full path identifier
 * of the property separated by '/' and the namespace level.
 *
 * @param {Array} namespace - The list of the nested namepsaces from startint
 *      at the root level.
 *      e.g. account/company/employee => ['account', 'company', 'employee']
 * @param {string} prop - Name of an object property
 * @return {Array} - An array with 3 elements,
 *      [0]: the uppercase-snakecase identifier e.g. ACCOUNT_COMPANY_NAME
 *      [1]: the full path of the property considering the namespace e.g.
 *              account/company/name
 *      [2]: The namespace level (i.e. @param namespace.length)
 */
function propMapper (namespace, prop) {
  const ctp = (namespace.length === 0) ? [prop] : [...namespace, prop]
  return [toTypeConst(ctp), ctp.join('/'), namespace.length]
}

function extract (store, namespace) {
  const mapFn = propMapper.bind(null, namespace)

  if (store.getters) {
    const getts = Object.keys(store.getters).map(mapFn)
    getters.push(...getts)
  }

  if (store.mutations) {
    const muts = Object.keys(store.mutations).map(mapFn)
    mutations.push(...muts)
  }

  if (store.actions) {
    const acts = Object.keys(store.actions).map(mapFn)
    actions.push(...acts)
  }

  if (store.modules) {
    Object.keys(store.modules).forEach(m => {
      let sm = store.modules[m]

      if (sm.namespaced) {
        extract(sm, [...namespace, m])
        return
      }

      extract(sm, namespace)
    })
  }
}
/**
 * Generate a uppercase and snakecase string from the full path (from the root
 * store to the mutation/action name, which can be in a submodule).
 * The generated string also convert any camelCase to snakecase
 *
 * @param {string[]} typePath - The mutation/action full path (namespace/type),
 *      e.g.
 *        - a global action: ['getProfile']
 *        - an action of an account module attached as a module of the root
 *              store: ['account', 'login']
 *        - a mutation of a settings module which is a module of the account
 *              module: ['account', 'settings', 'resetPassoword']
 * @return {string} The uppercased and snakecase representation of the typePath
 *      e.g ACCOUNT_SETTINGS_RESET_PASSWORD
 */
function toTypeConst (typePath) {
  return typePath.map(t => snakeCase(t).toUpperCase()).join('_')
}

function exitWithError (msg) {
  console.error(msg)
  process.exit(1)
}
